<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>CorrigePen PRO - Automático</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white overflow-hidden">
<div id="root"></div>

<script type="text/babel">
const { useEffect, useRef, useState } = React;

/* ================= CONFIG ATUALIZADA ================= */
const CONFIG = {
  startX: 377, 
  startY: 351, 
  gapX: 93,    
  gapY: 76,    
  size: 30,    
  threshold: 35000 
};

function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [scanAtual, setScanAtual] = useState([]);
  const [locked, setLocked] = useState(false);
  const [error, setError] = useState(null);
  
  // Estado para armazenar o gabarito vindo do Firebase
  const [gabarito, setGabarito] = useState(['A','B','C','A','B','C','A','B','C','A']); // Exemplo padrão
  const [notaFinal, setNotaFinal] = useState(0);

  useEffect(() => {
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
    }).then(stream => {
      videoRef.current.srcObject = stream;
    }).catch(() => setError("Erro ao acessar a câmera"));

    // AQUI VOCÊ PODE BUSCAR O GABARITO DO FIREBASE SE DESEJAR
    // db.ref('gabarito').once('value').then(snapshot => setGabarito(snapshot.val()));
  }, []);

  const salvarNotaAutomatica = (leiturasFinais) => {
    // Cálculo da nota comparando com o gabarito
    let acertos = 0;
    leiturasFinais.forEach((resp, i) => {
      if (resp === gabarito[i]) acertos++;
    });
    
    const calculo = (acertos / gabarito.length) * 10;
    setNotaFinal(calculo.toFixed(1));
    setScanAtual(leiturasFinais);
    setLocked(true); 

    // Opcional: Salvar nota no Firebase aqui
  };

  const processarFrame = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas || video.readyState < 2) return;

    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (canvas.width !== video.videoWidth) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    ctx.drawImage(video, 0, 0);
    const leitura = [];
    let contagemDetectadas = 0;

    for (let q = 0; q < 10; q++) {
      let dadosOpcoes = [];

      ['A','B','C'].forEach((opt, i) => {
        const x = CONFIG.startX + i * CONFIG.gapX;
        const y = CONFIG.startY + q * CONFIG.gapY;

        const pixels = ctx.getImageData(x, y, CONFIG.size, CONFIG.size).data;
        let escuro = 0;
        for (let p = 0; p < pixels.length; p += 4) {
          escuro += 255 - (pixels[p] + pixels[p+1] + pixels[p+2]) / 3;
        }

        ctx.strokeStyle = "rgba(255,255,255,0.15)";
        ctx.strokeRect(x, y, CONFIG.size, CONFIG.size);

        dadosOpcoes.push({ opt, escuro, x, y });
      });

      dadosOpcoes.sort((a, b) => b.escuro - a.escuro);
      const maisEscura = dadosOpcoes[0];
      const segundaMaisEscura = dadosOpcoes[1];

      if (maisEscura.escuro > CONFIG.threshold && maisEscura.escuro > segundaMaisEscura.escuro * 1.5) {
        ctx.fillStyle = "rgba(0,255,0,0.5)";
        ctx.beginPath();
        ctx.arc(maisEscura.x + CONFIG.size/2, maisEscura.y + CONFIG.size/2, CONFIG.size * 0.8, 0, Math.PI*2);
        ctx.fill();
        leitura.push(maisEscura.opt);
        contagemDetectadas++;
      } else {
        ctx.strokeStyle = "rgba(255,0,0,0.5)";
        ctx.lineWidth = 3;
        ctx.strokeRect(CONFIG.startX - 5, (CONFIG.startY + q * CONFIG.gapY) - 5, (CONFIG.gapX * 2) + CONFIG.size + 10, CONFIG.size + 10);
        leitura.push(null);
      }
    }
    
    setScanAtual(leitura);

    if (contagemDetectadas === 10 && !locked) {
        salvarNotaAutomatica(leitura);
    }
  };

  useEffect(() => {
    const timer = setInterval(() => {
      if (!locked) processarFrame();
    }, 150);
    return () => clearInterval(timer);
  }, [locked]);

  return (
    <div className="flex flex-col h-screen">
      <div className="relative flex-1">
        <video ref={videoRef} autoPlay playsInline className={`absolute w-full h-full object-cover ${locked ? 'opacity-40' : ''}`}/>
        <canvas ref={canvasRef} className="absolute w-full h-full object-cover"/>

        {!locked && (
            <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-blue-600/80 px-4 py-2 rounded-full text-xs font-bold uppercase tracking-widest border border-white/20">
                Aguardando 10 questões: {scanAtual.filter(r => r !== null).length}/10
            </div>
        )}

        {locked && (
          <div className="absolute inset-0 flex items-center justify-center p-6 bg-black/60">
            <div className="bg-slate-900 border-2 border-green-500 p-8 rounded-3xl shadow-2xl text-center w-full max-w-xs animate-bounce-short">
              <p className="text-green-400 font-bold text-sm uppercase tracking-widest mb-2">Correção Concluída</p>
              <h2 className="text-6xl font-black text-white mb-6">{notaFinal}</h2>
              <button 
                onClick={() => window.location.href = 'escaneamentodoqrcode.html'}
                className="w-full bg-green-600 hover:bg-green-500 text-white font-black py-4 rounded-2xl shadow-lg transition-transform active:scale-95"
              >
                PRÓXIMO ALUNO
              </button>
            </div>
          </div>
        )}
      </div>

      <div className="p-6 bg-slate-900 flex gap-4 pb-10">
        <div className="w-full text-center py-4 text-slate-400 text-sm font-medium animate-pulse">
            {locked ? "Nota Registrada!" : "Alinhe a câmera para capturar automaticamente"}
        </div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>

<style>
  @keyframes bounce-short {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
  .animate-bounce-short { animation: bounce-short 0.5s ease-in-out; }
</style>
</body>
</html>

