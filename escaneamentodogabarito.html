<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>CorrigePen PRO - Ultra EstÃ¡vel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white overflow-hidden">
<div id="root"></div>

<script type="text/babel">
const { useEffect, useRef, useState } = React;

const CONFIG = {
  startX: 318,
  startY: 345,
  gapX: 86,    
  gapY: 70,    
  size: 30,    
  threshold: 35000 
};

// Gabarito para teste (Substitua pelo carregado do Firebase se desejar)
const GABARITO_MESTRE = ['A','B','C','A','B','C','A','B','C','A'];

function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  
  // Estados de controle
  const [scanAtual, setScanAtual] = useState(new Array(10).fill(null));
  const [historico, setHistorico] = useState([]);
  const [locked, setLocked] = useState(false);
  const [cameraAtiva, setCameraAtiva] = useState(false);

  // Buffer para estabilizaÃ§Ã£o (votaÃ§Ã£o)
  const bufferLeitura = useRef(Array.from({ length: 10 }, () => []));

  useEffect(() => {
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
    }).then(stream => {
      videoRef.current.srcObject = stream;
      setCameraAtiva(true);
    }).catch(() => alert("Erro ao acessar a cÃ¢mera"));
  }, []);

  const playFeedback = (tipo) => {
    // VibraÃ§Ã£o (apenas Android)
    if (navigator.vibrate) navigator.vibrate(tipo === 'sucesso' ? 50 : 20);
    
    // Bip Sonoro
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = tipo === 'sucesso' ? 880 : 440;
    gain.gain.value = 0.1;
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
  };

  const processarFrame = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas || video.readyState < 2) return;

    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (canvas.width !== video.videoWidth) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    ctx.drawImage(video, 0, 0);
    const frameAtual = [];

    for (let q = 0; q < 10; q++) {
      let dadosOpcoes = [];

      ['A','B','C'].forEach((opt, i) => {
        const x = CONFIG.startX + i * CONFIG.gapX;
        const y = CONFIG.startY + q * CONFIG.gapY;
        const pixels = ctx.getImageData(x, y, CONFIG.size, CONFIG.size).data;
        let escuro = 0;
        for (let p = 0; p < pixels.length; p += 4) {
          escuro += 255 - (pixels[p] + pixels[p+1] + pixels[p+2]) / 3;
        }
        dadosOpcoes.push({ opt, escuro, x, y });
      });

      dadosOpcoes.sort((a, b) => b.escuro - a.escuro);
      const maisEscura = dadosOpcoes[0];
      const segunda = dadosOpcoes[1];

      let detected = null;
      if (maisEscura.escuro > CONFIG.threshold && maisEscura.escuro > segunda.escuro * 1.5) {
        detected = maisEscura.opt;
        // Feedback visual no canvas
        ctx.fillStyle = "rgba(0,255,0,0.5)";
        ctx.beginPath();
        ctx.arc(maisEscura.x + CONFIG.size/2, maisEscura.y + CONFIG.size/2, CONFIG.size * 0.8, 0, Math.PI*2);
        ctx.fill();
      }

      // EstabilizaÃ§Ã£o: Adiciona ao buffer e pega o mais frequente nos Ãºltimos 5 frames
      bufferLeitura.current[q].push(detected);
      if (bufferLeitura.current[q].length > 5) bufferLeitura.current[q].shift();
      
      const contagem = bufferLeitura.current[q].reduce((acc, v) => {
        acc[v] = (acc[v] || 0) + 1;
        return acc;
      }, {});
      
      const vencedor = Object.entries(contagem).sort((a,b) => b[1]-a[1])[0][0];
      frameAtual.push(vencedor === "null" ? null : vencedor);
    }
    setScanAtual(frameAtual);
  };

  useEffect(() => {
    const timer = setInterval(() => {
      if (!locked && cameraAtiva) processarFrame();
    }, 100);
    return () => clearInterval(timer);
  }, [locked, cameraAtiva]);

  const handleConfirmar = () => {
    const acertos = scanAtual.filter((r, i) => r === GABARITO_MESTRE[i]).length;
    const novaNota = {
      id: Date.now(),
      valor: (acertos / GABARITO_MESTRE.length * 10).toFixed(1),
      acertos: acertos,
      data: new Date().toLocaleTimeString()
    };
    
    setHistorico([novaNota, ...historico]);
    playFeedback('sucesso');
    setLocked(false);
  };

  return (
    <div className="flex flex-col h-screen font-sans">
      {/* AREA DE SCANNER */}
      <div className="relative flex-1 bg-black">
        <video ref={videoRef} autoPlay playsInline className={`absolute w-full h-full object-cover ${locked ? 'opacity-30' : ''}`}/>
        <canvas ref={canvasRef} className="absolute w-full h-full object-cover pointer-events-none"/>

        {/* FEEDBACK DE REVISÃƒO */}
        {locked && (
          <div className="absolute inset-x-4 top-4 bg-slate-900/95 border border-blue-500 p-4 rounded-2xl shadow-2xl animate-in slide-in-from-top duration-300">
            <h2 className="text-blue-400 font-black text-center mb-3 uppercase tracking-tighter">ConferÃªncia de Gabarito</h2>
            <div className="grid grid-cols-5 gap-2">
              {scanAtual.map((r, i) => (
                <div key={i} className={`flex flex-col items-center p-2 rounded-lg border ${r ? 'border-green-500/50 bg-green-500/10' : 'border-red-500/50 bg-red-500/10'}`}>
                  <span className="text-[10px] text-gray-400">Q{i+1}</span>
                  <span className="font-bold text-lg">{r || "?"}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* LISTA DE RESULTADOS (HISTÃ“RICO) */}
      <div className="h-24 bg-slate-950 border-t border-white/5 flex items-center px-4 gap-3 overflow-x-auto">
        {historico.length === 0 ? (
          <p className="text-gray-600 text-xs italic">Aguardando primeira correÃ§Ã£o...</p>
        ) : (
          historico.map(h => (
            <div key={h.id} className="bg-slate-900 border-l-4 border-green-500 px-4 py-2 rounded shadow-lg min-w-[100px]">
              <p className="text-[10px] text-gray-500 leading-none">{h.data}</p>
              <p className="text-xl font-black text-green-400 leading-tight">{h.valor}</p>
            </div>
          ))
        )}
      </div>

      {/* CONTROLES PRINCIPAIS */}
      <div className="p-4 bg-slate-900 border-t border-slate-800 flex gap-4 pb-8">
        {!locked ? (
          <button 
            onClick={() => { setLocked(true); playFeedback('click'); }} 
            className="w-full bg-blue-600 hover:bg-blue-500 active:scale-95 transition-all py-5 rounded-2xl text-xl font-black shadow-xl shadow-blue-900/20"
          >
            ðŸ“· CAPTURAR PROVA
          </button>
        ) : (
          <>
            <button 
              onClick={() => setLocked(false)} 
              className="flex-1 bg-slate-700 py-5 rounded-2xl font-bold text-sm uppercase"
            >
              Voltar
            </button>
            <button 
              onClick={handleConfirmar} 
              className="flex-[2] bg-green-600 hover:bg-green-500 active:scale-95 transition-all py-5 rounded-2xl text-xl font-black shadow-xl shadow-green-900/20"
            >
              Confirmar Nota
            </button>
          </>
        )}
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
</body>
</html>
