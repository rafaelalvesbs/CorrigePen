<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Leitor de Gabarito OMR</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

<style>
body {
    margin: 0;
    background: black;
    color: white;
    font-family: Arial;
    text-align: center;
}
video, canvas {
    width: 100%;
    max-height: 80vh;
}
button {
    padding: 12px 20px;
    margin: 10px;
    font-size: 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
}
</style>
</head>

<body>

<h2>Leitor de Gabarito</h2>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<button onclick="capturar()">üì∏ Capturar</button>

<script>
let video = document.getElementById("video");
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

// Ativa c√¢mera
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
.then(stream => video.srcObject = stream);

// Captura imagem
function capturar() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);
    processar();
}

function processar() {
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    cv.Canny(blur, edges, 75, 200);

    // Detecta contornos
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let biggest;
    let maxArea = 0;

    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if (area > maxArea) {
            biggest = cnt;
            maxArea = area;
        }
    }

    if (!biggest) {
        alert("Papel n√£o detectado");
        return;
    }

    // Aproxima para 4 pontos
    let peri = cv.arcLength(biggest, true);
    let approx = new cv.Mat();
    cv.approxPolyDP(biggest, approx, 0.02 * peri, true);

    if (approx.rows !== 4) {
        alert("N√£o foi poss√≠vel corrigir a inclina√ß√£o");
        return;
    }

    // Ordena pontos
    let pts = [];
    for (let i = 0; i < 4; i++) {
        pts.push({
            x: approx.intPtr(i,0)[0],
            y: approx.intPtr(i,0)[1]
        });
    }

    pts.sort((a,b) => a.y - b.y);
    let top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
    let bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);

    let srcPts = cv.matFromArray(4,1,cv.CV_32FC2,[
        top[0].x, top[0].y,
        top[1].x, top[1].y,
        bottom[1].x, bottom[1].y,
        bottom[0].x, bottom[0].y
    ]);

    let dstPts = cv.matFromArray(4,1,cv.CV_32FC2,[
        0,0,
        500,0,
        500,700,
        0,700
    ]);

    let M = cv.getPerspectiveTransform(srcPts, dstPts);
    let warped = new cv.Mat();
    cv.warpPerspective(src, warped, M, new cv.Size(500,700));

    // Binariza√ß√£o
    let finalGray = new cv.Mat();
    cv.cvtColor(warped, finalGray, cv.COLOR_RGBA2GRAY);
    cv.threshold(finalGray, finalGray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

    cv.imshow(canvas, finalGray);

    src.delete(); gray.delete(); blur.delete(); edges.delete();
    contours.delete(); hierarchy.delete(); approx.delete();
    warped.delete(); finalGray.delete();
}
</script>

</body>
</html>
