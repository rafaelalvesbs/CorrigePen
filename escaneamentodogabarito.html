<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scanner Offline PRO</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function App() {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [config, setConfig] = useState({ startX: 100, startY: 150, gapX: 45, gapY: 40 });
            const [results, setResults] = useState([]);
            const [viewMode, setViewMode] = useState('camera'); // camera ou calibragem

            useEffect(() => {
                navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 1280 } } 
                }).then(stream => videoRef.current.srcObject = stream);
                
                const interval = setInterval(processFrame, 200);
                return () => clearInterval(interval);
            }, [config]);

            const processFrame = () => {
                if (!videoRef.current || !canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d', { willReadFrequently: true });
                canvasRef.current.width = videoRef.current.videoWidth;
                canvasRef.current.height = videoRef.current.videoHeight;
                ctx.drawImage(videoRef.current, 0, 0);

                const newResults = [];
                for (let q = 0; q < 10; q++) { // 10 questões
                    let bestOpt = null;
                    let maxDarkness = 0;
                    
                    ['A', 'B', 'C', 'D', 'E'].forEach((opt, i) => {
                        const x = config.startX + (i * config.gapX);
                        const y = config.startY + (q * config.gapY);
                        
                        const imageData = ctx.getImageData(x, y, 20, 20);
                        const data = imageData.data;
                        let darkness = 0;
                        for (let p = 0; p < data.length; p += 4) {
                            darkness += (255 - (data[p] + data[p+1] + data[p+2]) / 3);
                        }

                        // Desenha o feedback visual
                        ctx.strokeStyle = darkness > 35000 ? "#00FF00" : "#FFFFFF";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, 20, 20);

                        if (darkness > 35000 && darkness > maxDarkness) {
                            maxDarkness = darkness;
                            bestOpt = opt;
                        }
                    });
                    newResults.push(bestOpt);
                }
                setResults(newResults);
            };

            return (
                <div class="flex flex-col h-screen overflow-hidden">
                    <div class="relative flex-1 bg-black">
                        <video ref={videoRef} autoPlay playsInline class="w-full h-full object-cover" />
                        <canvas ref={canvasRef} class="absolute top-0 left-0 w-full h-full object-cover" />
                        
                        {/* Painel de Controle Flutuante */}
                        <div class="absolute bottom-4 left-4 right-4 bg-white/10 backdrop-blur-md p-4 rounded-2xl border border-white/20">
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label class="text-[10px] block text-gray-400">POSIÇÃO INICIAL (X/Y)</label>
                                    <div class="flex gap-2">
                                        <input type="range" min="0" max="500" value={config.startX} onChange={e => setConfig({...config, startX: parseInt(e.target.value)})} class="w-full h-1" />
                                        <input type="range" min="0" max="500" value={config.startY} onChange={e => setConfig({...config, startY: parseInt(e.target.value)})} class="w-full h-1" />
                                    </div>
                                </div>
                                <div>
                                    <label class="text-[10px] block text-gray-400">ESPAÇAMENTO (X/Y)</label>
                                    <div class="flex gap-2">
                                        <input type="range" min="10" max="100" value={config.gapX} onChange={e => setConfig({...config, gapX: parseInt(e.target.value)})} class="w-full h-1" />
                                        <input type="range" min="10" max="100" value={config.gapY} onChange={e => setConfig({...config, gapY: parseInt(e.target.value)})} class="w-full h-1" />
                                    </div>
                                </div>
                            </div>
                            
                            <div class="flex overflow-x-auto gap-2 py-2">
                                {results.map((res, i) => (
                                    <div key={i} class={`min-w-[40px] h-10 flex items-center justify-center rounded-lg font-bold border ${res ? 'bg-green-600 border-green-400' : 'bg-white/5 border-white/20 text-gray-500'}`}>
                                        {res || '?'}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
