<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>CorrigePen PRO - EstÃ¡vel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white overflow-hidden">
<div id="root"></div>

<script type="text/babel">
const { useEffect, useRef, useState } = React;

/* ================= CONFIG ATUALIZADA BASEADA NA FOTO ================= */
const CONFIG = {
  startX: 318, // Ajustado levemente para a direita
  startY: 345, // Ajustado levemente para baixo
  gapX: 86,    
  gapY: 70,    
  size: 30,    // Aumentado para cobrir melhor a Ã¡rea
  threshold: 35000 // Um pouco mais sensÃ­vel
};

function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [scanAtual, setScanAtual] = useState([]);
  const [locked, setLocked] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
    }).then(stream => {
      videoRef.current.srcObject = stream;
    }).catch(() => setError("Erro ao acessar a cÃ¢mera"));
  }, []);

  const processarFrame = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas || video.readyState < 2) return;

    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (canvas.width !== video.videoWidth) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    ctx.drawImage(video, 0, 0);
    const leitura = [];

    for (let q = 0; q < 10; q++) {
      let dadosOpcoes = [];

      ['A','B','C'].forEach((opt, i) => {
        const x = CONFIG.startX + i * CONFIG.gapX;
        const y = CONFIG.startY + q * CONFIG.gapY;

        const pixels = ctx.getImageData(x, y, CONFIG.size, CONFIG.size).data;
        let escuro = 0;
        for (let p = 0; p < pixels.length; p += 4) {
          escuro += 255 - (pixels[p] + pixels[p+1] + pixels[p+2]) / 3;
        }

        // Desenha borda de debug
        ctx.strokeStyle = "rgba(255,255,255,0.15)";
        ctx.strokeRect(x, y, CONFIG.size, CONFIG.size);

        dadosOpcoes.push({ opt, escuro, x, y });
      });

      // Ordena para achar a opÃ§Ã£o mais escura
      dadosOpcoes.sort((a, b) => b.escuro - a.escuro);
      const maisEscura = dadosOpcoes[0];
      const segundaMaisEscura = dadosOpcoes[1];

      // LÃ³gica de Certeza: A mais escura deve ser maior que o threshold 
      // E significativamente mais escura que a segunda opÃ§Ã£o (evita ruÃ­do)
      if (maisEscura.escuro > CONFIG.threshold && maisEscura.escuro > segundaMaisEscura.escuro * 1.5) {
        ctx.fillStyle = "rgba(0,255,0,0.5)";
        ctx.beginPath();
        ctx.arc(maisEscura.x + CONFIG.size/2, maisEscura.y + CONFIG.size/2, CONFIG.size * 0.8, 0, Math.PI*2);
        ctx.fill();
        leitura.push(maisEscura.opt);
      } else {
        // Feedback visual de erro: questÃ£o nÃ£o identificada
        ctx.strokeStyle = "rgba(255,0,0,0.5)";
        ctx.lineWidth = 3;
        ctx.strokeRect(CONFIG.startX - 5, (CONFIG.startY + q * CONFIG.gapY) - 5, (CONFIG.gapX * 2) + CONFIG.size + 10, CONFIG.size + 10);
        leitura.push(null);
      }
    }
    setScanAtual(leitura);
  };

  useEffect(() => {
    const timer = setInterval(() => {
      if (!locked) processarFrame();
    }, 150);
    return () => clearInterval(timer);
  }, [locked]);

  return (
    <div className="flex flex-col h-screen">
      <div className="relative flex-1">
        <video ref={videoRef} autoPlay playsInline className={`absolute w-full h-full object-cover ${locked ? 'opacity-40' : ''}`}/>
        <canvas ref={canvasRef} className="absolute w-full h-full object-cover"/>

        {locked && (
          <div className="absolute left-4 top-4 bg-black/90 border border-green-500 p-4 rounded-xl shadow-2xl">
            <p className="text-green-400 font-bold mb-2 text-sm uppercase tracking-widest">RevisÃ£o de Leitura</p>
            <div className="grid grid-cols-2 gap-x-6 gap-y-1 font-mono text-sm">
              {scanAtual.map((r,i)=>(
                <div key={i} className="flex justify-between border-b border-white/10 w-24">
                  <span className="text-gray-500">{i+1}:</span>
                  <span className={r ? "text-white font-bold" : "text-red-500"}>{r || "?"}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      <div className="p-6 bg-slate-900 flex gap-4 pb-10">
        {!locked ? (
          <button onClick={()=>setLocked(true)} className="w-full bg-blue-600 py-6 rounded-2xl text-xl font-black shadow-lg active:scale-95 transition-transform">
            ðŸ“· ESCANEAR AGORA
          </button>
        ) : (
          <>
            <button onClick={()=>setLocked(false)} className="flex-1 bg-slate-700 py-6 rounded-2xl font-bold uppercase text-sm">Voltar</button>
            <button onClick={()=>{alert("Nota Salva!"); setLocked(false);}} className="flex-[2] bg-green-600 py-6 rounded-2xl text-xl font-black shadow-lg">Confirmar</button>
          </>
        )}
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
</body>
</html>
