<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner Inteligente OMR</title>
    <script src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; font-family: sans-serif; overflow: hidden; color: white; }
        
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
        }

        .loader {
            border: 4px solid #333; border-top: 4px solid #00ff00;
            border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        
        .overlay-guide {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; height: 60%; border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 20px; pointer-events: none; z-index: 5;
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.5);
        }

        .status-bar {
            position: absolute; top: 20px; left: 0; width: 100%; text-align: center;
            z-index: 10; padding: 10px; background: rgba(0,0,0,0.7);
        }

        #btn-capture {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            padding: 18px 45px; background: #00ff00; color: #000; border: none;
            border-radius: 40px; font-weight: bold; font-size: 18px; 
            display: none; z-index: 20; cursor: pointer; box-shadow: 0 4px 15px rgba(0,255,0,0.3);
        }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="loader"></div>
    <p style="margin-top: 15px;">Iniciando Visão Computacional...</p>
</div>

<div class="container">
    <div class="status-bar">
        <h3 id="info-text">Aguardando Câmera...</h3>
        <p id="sub-info">Aponte para as bolinhas marcadas</p>
    </div>

    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="canvas-draw"></canvas>
    <div class="overlay-guide"></div>

    <button id="btn-capture">CAPTURAR ACERTOS</button>
</div>

<audio id="beep" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>

<script>
    const video = document.getElementById('video-feed');
    const canvas = document.getElementById('canvas-draw');
    const ctx = canvas.getContext('2d');
    const infoText = document.getElementById('info-text');
    const btnCapture = document.getElementById('btn-capture');
    const loadingScreen = document.getElementById('loading-screen');
    const beep = document.getElementById('beep');

    let streamStarted = false;

    // 1. Inicialização Segura do OpenCV
    function checkOpenCV() {
        if (typeof cv !== 'undefined' && cv.Mat) {
            console.log("OpenCV Pronto.");
            loadingScreen.style.display = 'none';
            initCamera();
        } else {
            setTimeout(checkOpenCV, 500);
        }
    }

    async function initCamera() {
        try {
            const constraints = {
                video: { facingMode: "environment", width: { ideal: 640 }, height: { ideal: 480 } }
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                streamStarted = true;
                startProcessing();
            };
        } catch (err) {
            alert("Erro ao acessar câmera: Use HTTPS ou Localhost.");
            infoText.innerText = "Erro na Câmera";
        }
    }

    // 2. Motor de Processamento de Imagem
    function startProcessing() {
        // Aloca memória fora do loop para performance
        let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let thresh = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        
        const cap = new cv.VideoCapture(video);

        function processFrame() {
            if (!streamStarted) return;

            try {
                cap.read(src);
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Redução de ruído para evitar falsos positivos
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                // Threshold Adaptativo: Detecta marcas pretas mesmo com sombras
                cv.adaptiveThreshold(blurred, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 4);

                // Encontra os contornos das bolinhas
                cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // Prepara o Canvas para desenho
                canvas.width = video.clientWidth;
                canvas.height = video.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let detectedCount = 0;
                const scaleX = canvas.width / video.videoWidth;
                const scaleY = canvas.height / video.videoHeight;

                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    let rect = cv.boundingRect(cnt);
                    let ratio = rect.width / rect.height;

                    // Filtro de Bolinha: Area entre 300 e 4000 pixels e formato circular (ratio ~1)
                    if (area > 300 && area < 4000 && ratio > 0.7 && ratio < 1.3) {
                        detectedCount++;
                        
                        // Desenha o círculo verde
                        ctx.beginPath();
                        ctx.arc(
                            (rect.x + rect.width/2) * scaleX, 
                            (rect.y + rect.height/2) * scaleY, 
                            (rect.width/2) * scaleX, 0, 2 * Math.PI
                        );
                        ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // Atualiza UI baseada na detecção
                if (detectedCount >= 3) {
                    infoText.innerText = detectedCount + " MARCAÇÕES DETECTADAS";
                    infoText.style.color = "#00ff00";
                    if (btnCapture.style.display !== 'block') {
                        btnCapture.style.display = 'block';
                        beep.play().catch(() => {});
                    }
                } else {
                    infoText.innerText = "BUSCANDO GABARITO...";
                    infoText.style.color = "white";
                    btnCapture.style.display = 'none';
                }

                requestAnimationFrame(processFrame);
            } catch (err) {
                console.error("Erro no processamento:", err);
                requestAnimationFrame(processFrame);
            }
        }

        processFrame();
    }

    // Iniciar tudo
    window.onload = checkOpenCV;

    btnCapture.onclick = () => {
        alert("Gabarito Processado com Sucesso!");
    };
</script>

</body>
</html>
