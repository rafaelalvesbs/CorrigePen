<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <title>CorrigePen PRO â€“ Fix Cam</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        // CONFIGURAÃ‡ÃƒO OMR (Suas coordenadas)
        const CONFIG = { startX: 315, startY: 340, gapX: 84, gapY: 69, size: 28, threshold: 38000 };
        const GABARITO_PADRAO = ['A','B','C','A','B','C','A','B','C','A'];

        function App() {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [scanAtual, setScanAtual] = useState([]);
            const [isLocked, setIsLocked] = useState(false);
            const [error, setError] = useState(null);

            // 1. INICIAR CÃ‚MERA COM TRATAMENTO DE ERRO
            useEffect(() => {
                const startVideo = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
                        });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                        }
                    } catch (err) {
                        setError("Erro ao acessar cÃ¢mera. Verifique as permissÃµes.");
                        console.error(err);
                    }
                };
                startVideo();
            }, []);

            // 2. LÃ“GICA DE PROCESSAMENTO
            const processarFrame = () => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                if (!video || !canvas || video.readyState < 2) return;

                const ctx = canvas.getContext("2d", { willReadFrequently: true });
                
                // Ajusta o canvas ao tamanho real do vÃ­deo
                if (canvas.width !== video.videoWidth) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }

                ctx.drawImage(video, 0, 0);

                const resultados = [];
                for (let q = 0; q < 10; q++) {
                    let marcada = null;
                    let maiorEscuro = 0;
                    let coordsEleita = null;

                    ['A','B','C'].forEach((opt, i) => {
                        const x = CONFIG.startX + i * CONFIG.gapX;
                        const y = CONFIG.startY + q * CONFIG.gapY;
                        
                        // Captura Ã¡rea do cÃ­rculo
                        const pixels = ctx.getImageData(x, y, CONFIG.size, CONFIG.size).data;
                        let escuro = 0;
                        for (let p = 0; p < pixels.length; p += 4) {
                            escuro += 255 - (pixels[p] + pixels[p+1] + pixels[p+2]) / 3;
                        }

                        // Desenha guia visual
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                        ctx.strokeRect(x, y, CONFIG.size, CONFIG.size);

                        if (escuro > CONFIG.threshold && escuro > maiorEscuro) {
                            maiorEscuro = escuro;
                            marcada = opt;
                            coordsEleita = { x, y };
                        }
                    });

                    // CIRCULO DE CONFIRMAÃ‡ÃƒO
                    if (marcada && coordsEleita) {
                        ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
                        ctx.beginPath();
                        ctx.arc(coordsEleita.x + CONFIG.size/2, coordsEleita.y + CONFIG.size/2, CONFIG.size, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = "#00FF00";
                        ctx.stroke();
                    }
                    resultados.push(marcada);
                }
                setScanAtual(resultados);
            };

            useEffect(() => {
                const interval = setInterval(() => {
                    if (!isLocked) processarFrame();
                }, 100);
                return () => clearInterval(interval);
            }, [isLocked]);

            if (error) return <div className="p-10 text-center text-red-500">{error}</div>;

            return (
                <div className="flex flex-col h-screen bg-black">
                    {/* CAMERA */}
                    <div className="relative flex-1 flex items-center justify-center overflow-hidden">
                        <video 
                            ref={videoRef} 
                            autoPlay 
                            playsInline 
                            className={`absolute w-full h-full object-cover ${isLocked ? 'opacity-30' : 'opacity-100'}`}
                        />
                        <canvas 
                            ref={canvasRef} 
                            className="absolute w-full h-full object-cover"
                        />
                        
                        {isLocked && (
                            <div className="absolute left-4 top-10 bg-black/80 border border-green-500 p-3 rounded-lg font-mono text-xs">
                                <p className="text-green-500 font-bold mb-1">REVISÃƒO:</p>
                                {scanAtual.map((r, i) => (
                                    <div key={i} className="flex gap-4 border-b border-white/10">
                                        <span>Q{i+1}:</span> <span className="text-white">{r || "-"}</span>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* BOTÃ•ES */}
                    <div className="p-6 bg-slate-900 flex gap-4">
                        {!isLocked ? (
                            <button 
                                onClick={() => setIsLocked(true)}
                                className="w-full bg-blue-600 py-6 rounded-2xl font-black text-xl uppercase"
                            >
                                ðŸ“· Capturar
                            </button>
                        ) : (
                            <>
                                <button onClick={() => setIsLocked(false)} className="flex-1 bg-slate-700 py-6 rounded-2xl font-bold uppercase">Voltar</button>
                                <button onClick={() => { alert("Nota Salva!"); setIsLocked(false); }} className="flex-[2] bg-green-600 py-6 rounded-2xl font-black text-xl uppercase">Confirmar</button>
                            </>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);
    </script>
</body>
</html>
