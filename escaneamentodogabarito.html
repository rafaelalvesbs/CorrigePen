<script type="text/babel">
const { useEffect, useRef, useState } = React;

const CONFIG = {
    startX: 377,
    startY: 351,
    gapX: 93,
    gapY: 76,
    size: 30,
    threshold: 35000
};

function App() {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const [scanAtual, setScanAtual] = useState([]);
    const [locked, setLocked] = useState(false);
    const [gabarito, setGabarito] = useState([]);
    const [notaFinal, setNotaFinal] = useState(0);

    useEffect(() => {
        const firebaseConfig = {
            apiKey: "AIzaSyCZ77ugK5a3pw-U0NH43F2x1bu09sS5pJg",
            authDomain: "correcao-de-provas-f315d.firebaseapp.com",
            projectId: "correcao-de-provas-f315d",
            databaseURL: "https://correcao-de-provas-f315d-default-rtdb.firebaseio.com",
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }

        const params = new URLSearchParams(window.location.search);
        const provaId = params.get("provaId");

        if (provaId) {
            firebase.database().ref(`gabaritos/${provaId}`).once('value').then(snapshot => {
                if (snapshot.exists()) {
                    const obj = snapshot.val();
                    const arr = Object.keys(obj)
                        .sort((a,b)=>Number(a)-Number(b))
                        .map(k => obj[k]);
                    setGabarito(arr);
                }
            });
        }

        navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
        }).then(stream => {
            videoRef.current.srcObject = stream;
        });
    }, []);

    // FUNÇÃO PARA TIRAR A FOTO E PROCESSAR
    const tirarFotoECorrigir = () => {
        if (locked || gabarito.length === 0) return;

        const video = videoRef.current;
        const canvas = canvasRef.current;
        if (!video || !canvas || video.readyState < 2) return;

        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        
        // Ajusta o tamanho do canvas para a resolução da foto
        canvas.width = 1080;
        canvas.height = 1920;

        // 1. Desenha o frame atual do vídeo no canvas (A "Foto")
        ctx.drawImage(video, 0, 0, 1080, 1920);

        // 2. Bloqueia a interface
        setLocked(true);

        const leitura = [];
        let contagemDetectadas = 0;

        // 3. Processa a imagem estática (mesma lógica que você já tinha)
        for (let q = 0; q < 10; q++) {
            let dadosOpcoes = [];
            ['A','B','C'].forEach((opt, i) => {
                const x = CONFIG.startX + i * CONFIG.gapX;
                const y = CONFIG.startY + q * CONFIG.gapY;
                const pixels = ctx.getImageData(x, y, CONFIG.size, CONFIG.size).data;
                let escuro = 0;
                for (let p = 0; p < pixels.length; p += 4) {
                    escuro += 255 - (pixels[p] + pixels[p+1] + pixels[p+2]) / 3;
                }
                
                // Feedback visual na foto tirada
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.strokeRect(x, y, CONFIG.size, CONFIG.size);
                
                dadosOpcoes.push({ opt, escuro, x, y });
            });

            dadosOpcoes.sort((a, b) => b.escuro - a.escuro);
            const maisEscura = dadosOpcoes[0];
            const segundaMaisEscura = dadosOpcoes[1];

            if (maisEscura.escuro > CONFIG.threshold && maisEscura.escuro > segundaMaisEscura.escuro * 1.5) {
                ctx.fillStyle = "rgba(0,255,0,0.7)";
                ctx.beginPath();
                ctx.arc(maisEscura.x + CONFIG.size/2, maisEscura.y + CONFIG.size/2, 25, 0, Math.PI*2);
                ctx.fill();
                leitura.push(maisEscura.opt);
                contagemDetectadas++;
            } else {
                leitura.push(null);
            }
        }

        // 4. Calcula a nota baseada na foto
        let acertos = 0;
        leitura.forEach((resp, i) => {
            if (resp === gabarito[i]) acertos++;
        });
        
        const calculo = acertos * 2;
        
        // Delay pequeno para simular processamento e mostrar o resultado
        setTimeout(() => {
            setNotaFinal(calculo.toFixed(1));
            setScanAtual(leitura);
        }, 800);
    };

    return (
        <div className="scanner-container">
            {/* O vídeo fica de fundo, mas paramos de processar frames em loop */}
            <video ref={videoRef} autoPlay playsinline id="camera-feed" className={locked ? 'opacity-20' : 'opacity-80'}/>
            <canvas ref={canvasRef} className={locked ? 'opacity-100' : 'opacity-0'} />
            
            <div className="ui-overlay">
                <div className="status-bar">
                    {locked ? (notaFinal > 0 ? "FOTO PROCESSADA" : "ANALISANDO...") : "ALINHE E TIRE A FOTO"}
                </div>
                
                <div className="corner top-left"></div>
                <div className="corner top-right" style={{borderLeft: 0, borderBottom: 0, right: '100px', top: '150px'}}></div>
                
                {!locked && (
                    <div className="absolute bottom-[250px] left-1/2 -translate-x-1/2 flex flex-col items-center gap-8 pointer-events-auto">
                        <div className="bg-blue-600/80 px-8 py-4 rounded-full text-2xl font-bold uppercase border border-white/20 text-white">
                            Pronto para capturar
                        </div>
                        
                        {/* BOTÃO DE TIRAR FOTO */}
                        <button 
                            onClick={tirarFotoECorrigir}
                            className="w-32 h-32 bg-white rounded-full border-8 border-green-500 flex items-center justify-center shadow-2xl active:scale-90 transition-transform"
                        >
                            <div className="w-20 h-20 bg-green-500 rounded-full"></div>
                        </button>
                    </div>
                )}

                {locked && notaFinal > 0 && (
                    <div className="absolute inset-0 flex items-center justify-center p-6 bg-black/60 pointer-events-auto">
                        <div className="bg-slate-900 border-4 border-green-500 p-12 rounded-[60px] shadow-2xl text-center w-[600px] animate-bounce-short">
                            <p className="text-green-400 font-bold text-3xl uppercase tracking-widest mb-4">Nota Final</p>
                            <h2 className="text-[150px] font-black text-white mb-10">{notaFinal}</h2>
                            <button 
                                onClick={() => window.location.reload()}
                                className="w-full bg-green-600 hover:bg-green-500 text-white font-black py-8 rounded-3xl text-4xl shadow-lg transition-transform active:scale-95"
                            >
                                PRÓXIMO ALUNO
                            </button>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
